#pragma once

#include <iostream>
#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <fstream>
#include "../Common_libs/Errors/Errors.hpp"
#include "../Common_libs/Color.hpp"

namespace MCGraph
{
    //Работа с именами от пользователя
    //Он же может писать вершины в произвольном порядке
    //И ждать те же имена на выходах
    class NamesEq_t final
    {
    public:
        NamesEq_t () = default;
        //  returns true if element was inserted
        bool AddInfo_NTO (int new_node , int old_node);
        int GetInfo_NTO (int node) const;
        int GetInfo_NTO (size_t node) const;

        bool AddInfo_OTN (int old_node , int new_node);
        int GetInfo_OTN (int node) const;
        int GetInfo_OTN (size_t node) const;

    private:
        std::unordered_map<int , int> new_TO_old_;
        std::unordered_map<int , int> old_TO_new_;
    };

    struct DFS_Bip_Out
    {
        bool is_biparatite_;
        std::vector<int> prove_;
    };

    //удобная стуктура для покраски
    struct Color
    {
        //USING
        //--------------------------------------------
        using type = char;

        static constexpr char START_VALUE = -1;
        static constexpr char BLUE = 0;
        static constexpr char RED = 1;
        //--------------------------------------------

        explicit operator bool () const noexcept { return data_ != START_VALUE; }
        bool empty () const noexcept { return data_ == START_VALUE; }

        bool is_blue () const noexcept { return data_ == BLUE; }
        
        //true if color was changed
        bool change_color() noexcept;

        //out char of data_ to print in std::cout ('b' or 'r')
        char print () const noexcept;

        //возвращает другой цвет
        char get_another() const noexcept;

        bool operator == (const Color &that) const noexcept {return data_ == that.data_;}
        
        //DATA
        type data_ = START_VALUE;
    };
} // namespace MCGraph

//Mark Class
namespace MC
{
    //NT - Node type, ET - Edge type
    template <class ET = int , class NT = MCGraph::Color>
    class KGraph
    {
    public:
        KGraph () = default;
        KGraph (const KGraph&) = delete;
        KGraph (KGraph&&) = delete;

        KGraph (std::initializer_list<std::initializer_list<int>> data);

        void AddEdge (int left , int right , ET data = ET ());

        //!Debug
        /////////////////////////////////////////////////////////////////
        explicit operator bool () const noexcept { return !nodes_.empty (); }
        bool empty () const noexcept { return nodes_.empty (); }

        void dump (std::ostream& out) const;
        /////////////////////////////////////////////////////////////////

        //!WFS + DFS
        /////////////////////////////////////////////////////////////////
        std::vector<std::pair<int , int>> dumpWFS (int start_node = 0) const;

        //Возвращает структуру с проверкой на двудольность
        //Если is_bipartite_ = false
        //То в вектор prove_ заносится подстверждающий цикл нечётной длины 
        MCGraph::DFS_Bip_Out DFS_Bip ();

        //Возвращает раскраску текущего графа.
        //Используется после DFS_Bip для анализа покраски
        std::vector<std::pair<int , MCGraph::Color>> GetColors() const;
        /////////////////////////////////////////////////////////////////

    private:
        MCGraph::NamesEq_t names_nodes_;

        struct Node
        {
            int next_;
            int prev_;
            NT data_;
        };
        std::vector<Node> nodes_;
        struct Edge
        {
            int node_;
            int next_;
            int prev_;
            ET data_;
        };
        std::vector<Edge> edges_;

        void dumpWFS_Node (int node , int width , std::unordered_map<int , int>& marked_nodes) const;
        MCGraph::DFS_Bip_Out DFS_Bip_Node (int node);

        int PairNode (int node) const;

        static constexpr int END_FIND = -1;
    };

} // namespace MC
// operator << is below!